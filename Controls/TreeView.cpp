// TreeView.cpp: implementation of the CWTreeView class.
//
//////////////////////////////////////////////////////////////////////

#include "stdafx.h"

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CWTreeView::CWTreeView()
{
	this->m_strClassName	= "SysTreeView32";
}

CWTreeView::~CWTreeView()
{
}

////////////////////////////////////////////////////////////////////////////////
/// Purpose : 
/// Input   : 
/// Output  : 
////////////////////////////////////////////////////////////////////////////////
HTREEITEM CWTreeView::AddItem(char* text, HTREEITEM parent, int image, int selimage, DWORD data)
{
	TV_INSERTSTRUCT tvins;
	TV_ITEM tvi;

	tvi.mask = TVIF_TEXT | TVIF_IMAGE | TVIF_SELECTEDIMAGE | TVIF_PARAM;
	tvi.pszText = text;
	tvi.iImage = image;
	tvi.iSelectedImage = selimage;
	tvi.lParam = data;

	tvins.hParent = parent;
	tvins.hInsertAfter = TVI_LAST;
	tvins.item = tvi;

	HTREEITEM hi = TreeView_InsertItem(m_hWnd, &tvins);
	return hi;
}

////////////////////////////////////////////////////////////////////////////////
/// Purpose : 
/// Input   : 
/// Output  : 
////////////////////////////////////////////////////////////////////////////////
void CWTreeView::RemoveItem(HTREEITEM item)
{
	TreeView_DeleteItem(m_hWnd, item);
}

////////////////////////////////////////////////////////////////////////////////
/// Purpose : 
/// Input   : 
/// Output  : 
////////////////////////////////////////////////////////////////////////////////
void CWTreeView::ClearItems()
{
	TreeView_DeleteAllItems(m_hWnd);
}

////////////////////////////////////////////////////////////////////////////////
/// Purpose : 
/// Input   : 
/// Output  : 
////////////////////////////////////////////////////////////////////////////////
void CWTreeView::ClearChilds(HTREEITEM item)
{
	HTREEITEM child = TreeView_GetChild(m_hWnd, item);

	while (child)
	{
		TreeView_DeleteItem(m_hWnd, child);

		child = TreeView_GetChild(m_hWnd, item);
	}
}

////////////////////////////////////////////////////////////////////////////////
/// Purpose : 
/// Input   : 
/// Output  : 
////////////////////////////////////////////////////////////////////////////////
bool CWTreeView::HasChilds(HTREEITEM item)
{
	return TreeView_GetChild(m_hWnd, item) != NULL;
}

////////////////////////////////////////////////////////////////////////////////
/// Purpose : 
/// Input   : 
/// Output  : 
////////////////////////////////////////////////////////////////////////////////
const char* CWTreeView::GetItemText(HTREEITEM item)
{
	TVITEM tvi;
    static char* text = new char[255];
	tvi.hItem		=	item;
	tvi.cchTextMax	=	255;
	tvi.pszText		=	text;
	tvi.mask		=	TVIF_TEXT;

	if(SendMessage(m_hWnd, TVM_GETITEM, 0, (LPARAM)&tvi))
		return text;
	return "";
}

////////////////////////////////////////////////////////////////////////////////
/// Purpose : 
/// Input   : 
/// Output  : 
////////////////////////////////////////////////////////////////////////////////
DWORD CWTreeView::GetItemData(HTREEITEM item)
{
	TVITEM tvi;
	char* text = new char[255];
	tvi.hItem		=	item;
	tvi.cchTextMax	=	255;
	tvi.pszText		=	text;
	tvi.mask		=	TVIF_TEXT;

	SendMessage(m_hWnd, TVM_GETITEM, 0, (LPARAM)&tvi);
	return tvi.lParam;
}

////////////////////////////////////////////////////////////////////////////////
/// Purpose : 
/// Input   : 
/// Output  : 
////////////////////////////////////////////////////////////////////////////////
HTREEITEM CWTreeView::GetSelectedItem()
{
	return TreeView_GetSelection(m_hWnd);
}

////////////////////////////////////////////////////////////////////////////////
/// Purpose : 
/// Input   : 
/// Output  : 
////////////////////////////////////////////////////////////////////////////////
HTREEITEM CWTreeView::GetParentItem(HTREEITEM item)
{
	return TreeView_GetParent(m_hWnd, item);
}

////////////////////////////////////////////////////////////////////////////////
/// Purpose : 
/// Input   : 
/// Output  : 
////////////////////////////////////////////////////////////////////////////////
HTREEITEM CWTreeView::GetChild(HTREEITEM parent, int index)
{
	HTREEITEM firstChild = TreeView_GetChild(m_hWnd, parent);

	if (index == 0)
	{
		return firstChild;
	}
	else
	{
		HTREEITEM child = firstChild;
		for (int i = 0; i < index; i++)
		{
			child = TreeView_GetNextSibling(m_hWnd, child);
		}
		return child;
	}
}

////////////////////////////////////////////////////////////////////////////////
/// Purpose : 
/// Input   : 
/// Output  : 
////////////////////////////////////////////////////////////////////////////////
HTREEITEM CWTreeView::GetFirstChild(HTREEITEM parent)
{
	return TreeView_GetChild(m_hWnd, parent);
}

////////////////////////////////////////////////////////////////////////////////
/// Purpose : 
/// Input   : 
/// Output  : 
////////////////////////////////////////////////////////////////////////////////
HTREEITEM CWTreeView::GetNextSibling(HTREEITEM item)
{
	return TreeView_GetNextSibling(m_hWnd, item);
}

////////////////////////////////////////////////////////////////////////////////
/// Purpose : 
/// Input   : 
/// Output  : 
////////////////////////////////////////////////////////////////////////////////
void CWTreeView::Expand(HTREEITEM item)
{
	TreeView_Expand(this->m_hWnd, item, TVE_EXPAND);
}

////////////////////////////////////////////////////////////////////////////////
/// Purpose : 
/// Input   : 
/// Output  : 
////////////////////////////////////////////////////////////////////////////////
void CWTreeView::Collapse(HTREEITEM item)
{
	TreeView_Expand(this->m_hWnd, item, TVE_COLLAPSE);
}

////////////////////////////////////////////////////////////////////////////////
/// Purpose : 
/// Input   : 
/// Output  : 
////////////////////////////////////////////////////////////////////////////////
HIMAGELIST CWTreeView::SetNormalImageList(HIMAGELIST himl)
{
	return TreeView_SetImageList(m_hWnd, himl, LVSIL_NORMAL);
}

////////////////////////////////////////////////////////////////////////////////
/// Purpose : 
/// Input   : 
/// Output  : 
////////////////////////////////////////////////////////////////////////////////
void CWTreeView::SetCheckState(HTREEITEM item, bool state)
{
	TVITEM tvItem;

    tvItem.mask = TVIF_HANDLE | TVIF_STATE;
    tvItem.hItem = item;
    tvItem.stateMask = TVIS_STATEIMAGEMASK;

    /*
    Since state images are one-based, 1 in this macro turns the check off, and 
    2 turns it on.
    */
    tvItem.state = INDEXTOSTATEIMAGEMASK((state ? 2 : 1));

    TreeView_SetItem(m_hWnd, &tvItem);

}

////////////////////////////////////////////////////////////////////////////////
/// Purpose : 
/// Input   : 
/// Output  : 
////////////////////////////////////////////////////////////////////////////////
bool CWTreeView::GetCheckState(HTREEITEM item)
{
	TVITEM tvItem;

    // Prepare to receive the desired information.
    tvItem.mask = TVIF_HANDLE | TVIF_STATE;
    tvItem.hItem = item;
    tvItem.stateMask = TVIS_STATEIMAGEMASK;

    // Request the information.
    TreeView_GetItem(m_hWnd, &tvItem);

    // Return zero if it's not checked, or nonzero otherwise.
    return ((tvItem.state >> 12) -1) == 0;
}

////////////////////////////////////////////////////////////////////////////////
/// Purpose : 
/// Input   : 
/// Output  : 
////////////////////////////////////////////////////////////////////////////////
HTREEITEM CWTreeView::HitTestCursor()
{
	POINT pt;
	GetCursorPos(&pt);
	ScreenToClient(m_hWnd, &pt);
	TVHITTESTINFO htinfo;
	htinfo.pt.x = pt.x;
	htinfo.pt.y = pt.y;
	htinfo.flags = TVHT_ONITEM;

	TreeView_HitTest(m_hWnd, &htinfo);

	return htinfo.hItem;
}
